{
  "version": 3,
  "sources": ["external-global-plugin:leaflet", "../../src/wxtiles.ts", "../../src/wxtools.ts", "../../src/RawCLUT.ts", "../../src/mercator.ts", "../../src/tile.ts", "../../src/tileLayer.js"],
  "sourcesContent": ["module.exports = window.L", "// https://everythingfonts.com/ttf-to-woff - converter\n// https://caniuse.com/?search=woff\nimport './styles.css';\n\nimport { WxGridLayerProto } from './tileLayer';\nexport { WxTileLibSetup, WxGetColorStyles, ColorStylesWeakMixed, Units, ColorSchemes, LibSetupObject } from './wxtools';\n\nimport L from 'leaflet';\n\n// const L = window.L;\nconst WxGridLayerL = L.GridLayer.extend(WxGridLayerProto);\n\nexport function WxTileLayer(settings: any) {\n\tconst layer = new WxGridLayerL();\n\tlayer.initializeLayer(settings);\n\treturn layer;\n}\n\nconst WatermarkProto = {\n\toptions: { URI: '' },\n\tonAdd() {\n\t\tconst w = document.createElement('img');\n\t\tw.src = this.options.URI;\n\t\tw.className = 'wxtiles-logo';\n\t\treturn w;\n\t},\n};\n\nconst WxWatermark = L.Control.extend(WatermarkProto);\n\nexport function WxTileWatermark(options: any) {\n\tif (window.wxlogging) {\n\t\tconsole.log('Add watermark:', JSON.stringify(options));\n\t}\n\n\treturn new WxWatermark(options);\n}\n\nconst WxDebugLayer = L.GridLayer.extend({\n\tcreateTile(coords: { x: number; y: number; z: number }) {\n\t\tconst tile = document.createElement('div');\n\t\ttile.innerHTML = [coords.x, coords.y, coords.z].join(', ');\n\t\ttile.style.outline = '1px solid red';\n\t\treturn tile;\n\t},\n});\n\nexport function WxDebugCoordsLayer() {\n\tif (window.wxlogging) {\n\t\tconsole.log('Add WxDebugCoordsLayer:');\n\t}\n\tconst debLayer = new WxDebugLayer();\n\tdebLayer.setZIndex(1000);\n\treturn debLayer;\n}\n\nexport function WxTileGroupLayer(group) {\n\treturn L.layerGroup(group.map(WxTileLayer));\n}\n\nexport function WxTileLogging(on) {\n\tif (on) {\n\t\tconsole.log('Logging on');\n\t} else {\n\t\tconsole.log('Logging off');\n\t}\n\twindow.wxlogging = on;\n}\n", "export type UnitTuple = [string, number, number?];\n\nexport interface Units {\n\t[unit: string]: UnitTuple;\n}\n\nconst __units_default_preset: Units = {\n\tcomment1: [\"degC: ['K', 1, 273.15] -> degC = K * 1 + 273.15\", 0],\n\tcomment2: [\"hPa: ['Pa', 100]' -> hPa = Pa * 100 + 0 (0 - could be ommited)\", 0],\n\tK: ['K', 1],\n\tF: ['K', 0.5555555555, 255.372222222],\n\tC: ['K', 1, 273.15],\n\tdegC: ['K', 1, 273.15],\n\t'kg/m^2/s': ['kg/m^2/s', 1],\n\t'Kg m**-2 s**-1': ['kg/m^2/s', 1],\n\t'W/m^2': ['W/m^2', 1],\n\t'W m**2': ['W/m^2', 1],\n\t'm/s': ['m/s', 1],\n\t'm s**-1': ['m/s', 1],\n\tknot: ['m/s', 0.514444],\n\tknots: ['m/s', 0.514444],\n\t'km/h': ['m/s', 0.27777777777],\n\ts: ['s', 1],\n\tsec: ['s', 1],\n\th: ['s', 3600],\n\tmin: ['s', 60],\n\tm: ['m', 1],\n\tcm: ['m', 0.01],\n\tinch: ['m', 0.0254],\n\tPa: ['Pa', 1],\n\thPa: ['Pa', 100],\n};\n\nexport interface ColorSchemes {\n\t[name: string]: string[];\n}\n\nconst __colorSchemes_default_preset: ColorSchemes = {\n\tnone: ['#00000000', '#00000000'],\n\trainbow: ['#f00', '#ff0', '#0f0', '#0ff', '#00f', '#f0f'],\n\trainbow2: ['#f00', '#ff0', '#0f0', '#0ff', '#00f', '#f0f', '#f00'],\n\trainbowzerro: ['#ff000000', '#f00', '#ff0', '#0f0', '#0ff', '#00f', '#f0f'],\n\tbluebird: ['#00f', '#f0f', '#0ff', '#80f', '#88f'],\n\tbluebirdzerro: ['#0000ff00', '#00f', '#f0f', '#0ff', '#80f', '#88f'],\n\tbw: ['#000', '#fff'],\n\twb: ['#fff', '#000'],\n\tredish: ['#f0f', '#f00', '#ff0'],\n\tgreenish: ['#ff0', '#0f0', '#0ff'],\n\tblueish: ['#f0f', '#00f', '#0ff'],\n\thspastel: ['#AC6EA4FF', '#8E92BDFF', '#ACD4DEFF', '#E9DC8EFF', '#E7A97DFF', '#E59074FF', '#BE7E68FF', '#A88F86FF'],\n};\n\nexport type colorMapTuple = [number, string];\n\nexport interface ColorStyleWeak {\n\tparent?: string;\n\tname?: string;\n\tfill?: string;\n\tisolineColor?: string;\n\tisolineText?: boolean;\n\tvectorType?: string;\n\tvectorColor?: string;\n\tstreamLineColor?: string;\n\tstreamLineSpeedFactor?: number;\n\tstreamLineStatic?: boolean;\n\tshowBelowMin?: boolean;\n\tshowAboveMax?: boolean;\n\tcolorScheme?: string;\n\tcolors?: string[];\n\tcolorMap?: colorMapTuple[];\n\tlevels?: number[];\n\tblurRadius?: number;\n\taddDegrees?: number;\n\tunits?: string;\n\textraUnits?: Units; //{ [name: string]: [string, number, ?number] };\n}\n\nexport interface ColorStylesWeakMixed {\n\t[name: string]: ColorStyleWeak | ColorStyleWeak[];\n}\nexport interface ColorStylesIncomplete {\n\t[name: string]: ColorStyleWeak;\n}\n\nexport interface ColorStyleStrict {\n\tparent?: string;\n\tname: string;\n\tfill: string;\n\tisolineColor: string;\n\tisolineText: boolean;\n\tvectorType: string;\n\tvectorColor: string;\n\tstreamLineColor: string;\n\tstreamLineSpeedFactor: number;\n\tstreamLineStatic: boolean;\n\tshowBelowMin: boolean;\n\tshowAboveMax: boolean;\n\tcolorScheme: string;\n\tcolors?: string[];\n\tcolorMap?: [number, string][];\n\tlevels?: number[];\n\tblurRadius: number;\n\taddDegrees: number;\n\tunits: string;\n\textraUnits?: Units; //{ [name: string]: [string, number, ?number] };\n}\n\nexport interface ColorStylesStrict {\n\t[name: string]: ColorStyleStrict;\n}\n\nconst __colorStyles_default_preset: ColorStylesStrict = {\n\tbase: {\n\t\tparent: undefined,\n\t\tname: 'base',\n\t\tfill: 'gradient',\n\t\tisolineColor: 'inverted',\n\t\tisolineText: true,\n\t\tvectorType: 'arrows',\n\t\tvectorColor: 'inverted',\n\t\tstreamLineColor: '#777',\n\t\tstreamLineSpeedFactor: 1,\n\t\tstreamLineStatic: false,\n\t\tshowBelowMin: true,\n\t\tshowAboveMax: true,\n\t\tcolorScheme: 'rainbow',\n\t\tcolors: undefined,\n\t\tcolorMap: undefined,\n\t\tlevels: undefined,\n\t\tblurRadius: 0,\n\t\taddDegrees: 0,\n\t\tunits: '',\n\t\textraUnits: undefined,\n\t},\n\tcustom: {\n\t\tparent: undefined,\n\t\tname: 'custom',\n\t\tfill: 'gradient',\n\t\tisolineColor: 'inverted',\n\t\tisolineText: true,\n\t\tvectorType: 'arrows',\n\t\tvectorColor: 'inverted',\n\t\tstreamLineColor: '#777',\n\t\tstreamLineSpeedFactor: 1,\n\t\tstreamLineStatic: false,\n\t\tshowBelowMin: true,\n\t\tshowAboveMax: true,\n\t\tcolorScheme: 'rainbow',\n\t\tcolors: undefined,\n\t\tcolorMap: undefined,\n\t\tlevels: undefined,\n\t\tblurRadius: 0,\n\t\taddDegrees: 0,\n\t\tunits: '',\n\t\textraUnits: undefined,\n\t},\n};\n\ndeclare global {\n\tinterface Window {\n\t\twxlogging: boolean;\n\t\tL: any; // reference to the external Leaflet library\n\t}\n}\n\nlet _units: Units;\nlet _colorSchemes: ColorSchemes;\nlet _colorStylesUnrolled: ColorStylesStrict;\n\nexport interface LibSetupObject {\n\tcolorStyles?: ColorStylesWeakMixed;\n\tunits?: Units;\n\tcolorSchemes?: ColorSchemes;\n}\n\n/// some random usefull stuff\nexport function WxTileLibSetup({ colorStyles = {}, units = {}, colorSchemes = {} }: LibSetupObject = {}): void {\n\tif (window.wxlogging) {\n\t\tconsole.log('WxTile lib setup: start');\n\t}\n\t_units = Object.assign({}, __units_default_preset, units);\n\t_colorSchemes = Object.assign({}, colorSchemes, __colorSchemes_default_preset);\n\t// const toUnroll = Object.assign({}, colorStyles, __colorStyles_default_preset);\n\t_colorStylesUnrolled = unrollStylesParent(colorStyles);\n\tif (window.wxlogging) {\n\t\tconsole.log('WxTile lib setup: styles unrolled');\n\t}\n\n\t// Make sure fonts are loaded & ready!\n\tdocument.fonts.load('32px barbs');\n\tdocument.fonts.load('32px arrows');\n\n\tif (window.wxlogging) {\n\t\tconsole.log('WxTile lib setup is done' + JSON.stringify({ colorStyles, units, colorSchemes }));\n\t}\n}\n\nexport function WxGetColorStyles(): ColorStylesStrict {\n\treturn _colorStylesUnrolled;\n}\n\nexport function getColorSchemes(): ColorSchemes {\n\treturn _colorSchemes;\n}\n\nexport interface Converter {\n\t(x: number): number;\n\ttrivial?: boolean;\n}\n\nexport function makeConverter(from: string, to: string, customUnits?: Units): Converter {\n\tconst localUnitsCopy = customUnits ? Object.assign({}, _units, customUnits) : _units;\n\tif (!localUnitsCopy || !from || !to || from === to || !localUnitsCopy[from] || !localUnitsCopy[to] || localUnitsCopy[from][0] !== localUnitsCopy[to][0]) {\n\t\tif (window.wxlogging) {\n\t\t\tconsole.log(from === to ? 'Trivial converter:' : 'Inconvertible units. Default converter is used:', from, ' -> ', to);\n\t\t}\n\t\tconst c = (x: number) => x;\n\t\tc.trivial = true;\n\t\treturn c; // Inconvertible or trivial\n\t}\n\n\tif (window.wxlogging) console.log('Converter: From:', from, ' To:', to);\n\tconst a = localUnitsCopy[from][1] / localUnitsCopy[to][1];\n\tconst b = (localUnitsCopy[from][2] || 0) / localUnitsCopy[to][1] - (localUnitsCopy[to][2] || 0) / localUnitsCopy[to][1];\n\treturn b ? (x: number) => a * x + b : (x: number) => a * x;\n}\n\nfunction unrollStylesParent1(stylesIn: ColorStylesWeakMixed): ColorStylesStrict {\n\t// unroll arrays of styles => plain styles to apply ineritance\n\t/*\n\t{\n\t\t\"var\":[\n\t\t\t{style1},\n\t\t\t{style2}\n\t\t]\n\t}\n\t unrolled into\n\t{\n\t\t\"var\":[\n\t\t\t{style1},\n\t\t\t{style2}\n\t\t],\n\t\t\"var[0]\":{*style1},\n\t\t\"var[1]\":{*style2},\n\t}\n\tI use softycopy, so {*style1} === {style1}, etc.\n\tSo it's easier to apply inheritance.\n\t*/\n\tconst deArrStyles = <ColorStylesWeakMixed>Object.assign({}, stylesIn, __colorStyles_default_preset); // deep copy, so could be (and is) changed\n\tconst deArrStyles2 = Object.assign({}, __colorStyles_default_preset);\n\tfor (const name in deArrStyles) {\n\t\tconst styleA = deArrStyles[name];\n\t\tif (Array.isArray(styleA)) {\n\t\t\tfor (let i = 0; i < styleA.length; ++i) {\n\t\t\t\tdeArrStyles[name + '[' + i + ']'] = styleA[i];\n\t\t\t}\n\t\t\tdelete deArrStyles[name];\n\t\t}\n\t}\n\n\tconst styles = <ColorStylesStrict>Object.assign({}, deArrStyles);\n\n\t// function to apply inheritance\n\tconst inheritParent = (styleName: string): void => {\n\t\tif (styleName === 'base') return; // nothing to inherit\n\t\tconst style = styles[styleName]; // there are no arrays by this point\n\t\tif (!style.parent || !(style.parent in styles)) style.parent = 'base';\n\t\tinheritParent(style.parent);\n\t\tObject.assign(style, Object.assign({}, styles[style.parent], style)); // this ugly construction changes style 'in place' so it is a soft-copy. huray!\n\t\tstyle.parent = undefined; // multiple inheritance of 'base' is possible. what ever...\n\t};\n\n\t// For every style inherit from its parent\n\tObject.keys(styles).forEach(inheritParent);\n\treturn styles;\n}\n\nfunction unrollStylesParent(stylesArrInc: ColorStylesWeakMixed): ColorStylesStrict {\n\tconst stylesInc: ColorStylesIncomplete = Object.assign({}, __colorStyles_default_preset);\n\tfor (const name in stylesArrInc) {\n\t\tconst styleA = stylesArrInc[name];\n\t\tif (Array.isArray(styleA)) {\n\t\t\tfor (let i = 0; i < styleA.length; ++i) {\n\t\t\t\tstylesInc[name + '[' + i + ']'] = Object.assign({}, styleA[i]); // deep copy\n\t\t\t}\n\t\t} else {\n\t\t\tstylesInc[name] = Object.assign({}, styleA); // deep copy\n\t\t}\n\t}\n\n\t// recursive function to apply inheritance\n\tconst inherit = (stylesInc: ColorStylesIncomplete, name: string): ColorStyleStrict => {\n\t\tif (name === 'base') return __colorStyles_default_preset.base; // nothing to inherit\n\t\tconst style = stylesInc[name]; // there are no arrays by this point\n\t\tif (!style.parent || !(style.parent in stylesInc)) style.parent = 'base';\n\t\tconst parent = inherit(stylesInc, style.parent); // After inheritance it is FULL ColorStyle\n\t\treturn Object.assign(style, Object.assign({}, parent, style, { parent: 'base' })); // this ugly construction changes style 'in place' so it is a soft-copy. huray!\n\t};\n\n\tconst styles: ColorStylesStrict = {};\n\tfor (const name in stylesInc) {\n\t\tstyles[name] = inherit(stylesInc, name);\n\t}\n\n\treturn styles;\n}\n\ntype CacheableFunc = (url: string) => Promise<DataPicture>;\n\n// Caches\nfunction cacheIt(fn: CacheableFunc): CacheableFunc {\n\tconst cache = new Map<string, Promise<DataPicture>>();\n\treturn (url: string) => {\n\t\tlet res = cache.get(url);\n\t\tif (res === undefined) {\n\t\t\tres = fn(url);\n\t\t\tcache.set(url, res);\n\t\t}\n\t\treturn res;\n\t};\n}\n\n// abortable 'loadImage'\nasync function loadImage(url: string, signal: AbortSignal): Promise<HTMLImageElement> {\n\tconst img = new Image();\n\timg.crossOrigin = 'anonymous'; // essential\n\tconst abortFunc = () => {\n\t\timg.src = '';\n\t}; // stop loading\n\tsignal.addEventListener('abort', abortFunc);\n\t////// Method 1\n\timg.src = url;\n\tawait img.decode();\n\tsignal.removeEventListener('abort', abortFunc);\n\treturn img;\n\t//// Method 2\n\t// return new Promise((resolve) => {\n\t// \timg.onload = () => {signal.removeEventListener('abort', abortFunc);resolve(img);};\n\t// \timg.src = url; // should be after .onload\n\t// });\n}\n\ninterface IntegralPare {\n\tintegral: Uint32Array;\n\tintegralNZ: Uint32Array;\n}\n\nexport interface DataPicture {\n\traw: Uint16Array;\n\tdmin: number;\n\tdmax: number;\n\tdmul: number;\n}\n\nexport interface DataPictureIntegral extends DataPicture {\n\tintegral: IntegralPare;\n\tradius: number;\n}\n// http://webpjs.appspot.com/ = webp lossless decoder\n// https://chromium.googlesource.com/webm/libwebp/+/refs/tags/v0.6.1/README.webp_js\nasync function loadDataPicture(url: string, signal: AbortSignal): Promise<DataPictureIntegral> {\n\tconst pictureToData = (imData: ImageData): DataPictureIntegral => {\n\t\t// picTile contains bytes RGBARGBARGBA ...\n\t\t// we need RG and don't need BA, so output is a 16 byte array picData with every second value dropped.\n\t\tconst size = imData.height * imData.width;\n\t\tconst imbuf = new Uint16Array(imData.data.buffer);\n\t\tconst raw = new Uint16Array(size);\n\t\tfor (let i = 0; i < size; i++) {\n\t\t\traw[i] = imbuf[i * 2];\n\t\t}\n\n\t\tconst minmaxbuf = new Uint8Array(imData.data.buffer);\n\t\tfor (let i = 0; i < 8; ++i) {\n\t\t\tminmaxbuf[i] = minmaxbuf[i * 4 + 2];\n\t\t}\n\n\t\tconst view = new DataView(imData.data.buffer);\n\t\tconst dmin = view.getFloat32(0, true);\n\t\tconst dmax = view.getFloat32(4, true);\n\t\tconst dmul = (dmax - dmin) / 65535;\n\t\tconst integral = integralImage(raw);\n\t\treturn { raw, dmin, dmax, dmul, integral, radius: 0 };\n\t};\n\n\tconst context = Object.assign(document.createElement('canvas'), { width: 258, height: 258, imageSmoothingEnabled: false }).getContext('2d');\n\tif (!context) return Promise.reject();\n\tconst img = await loadImage(url, signal); ///*Old approach to solve 'crossorigin' and 'abort'*/ const img = await loadImage(URL.createObjectURL(await (await fetch(url, { signal, cache: 'force-cache' })).blob()));\n\tcontext.drawImage(img, 0, 0);\n\treturn pictureToData(context.getImageData(0, 0, 258, 258));\n}\n\nexport interface AbortableCacheableFunc extends CacheableFunc {\n\tabort(): void;\n}\n\nexport function loadDataPictureCachedAbortable() {\n\tconst controller = new AbortController();\n\tconst func = <AbortableCacheableFunc>cacheIt((url: string) => loadDataPicture(url, controller.signal));\n\tfunc.abort = () => controller.abort();\n\treturn func;\n}\n\n// Integarl image: https://en.wikipedia.org/wiki/Summed-area_table\n// used for fast box-blur algo\nfunction integralImage(raw: Uint16Array): IntegralPare {\n\tconst integral = new Uint32Array(258 * 258);\n\t// The main Idea of integralNZ is to calculate the amount of non zero values,\n\t// so in the Blur algorithm it can be used for 'averaging' instead of actual area of BoxBlur frame\n\tconst integralNZ = new Uint32Array(258 * 258);\n\n\tintegral[0] = raw[0]; // upper left value\n\tintegralNZ[0] = raw[0] === 0 ? 0 : 1; // upper left value\n\n\tfor (let i = 1; i < 258; ++i) {\n\t\t// boundaries\n\t\tintegral[i] = raw[i] + integral[i - 1]; // uper boundary\n\t\tintegral[258 * i] = raw[258 * i] + integral[258 * i - 258]; // left boundary\n\t\tintegralNZ[i] = (raw[i] === 0 ? 0 : 1) + integralNZ[i - 1]; // uper boundary\n\t\tintegralNZ[258 * i] = (raw[258 * i] === 0 ? 0 : 1) + integralNZ[258 * i - 258]; // left boundary\n\t}\n\n\tfor (let y = 1, i = 259; y < 258; ++y, ++i) {\n\t\t// the rest picture\n\t\tfor (let x = 1; x < 258; ++x, ++i) {\n\t\t\tintegral[i] = raw[i] + integral[i - 258] + integral[i - 1] - integral[i - 258 - 1];\n\t\t\tintegralNZ[i] = (raw[i] === 0 ? 0 : 1) + integralNZ[i - 258] + integralNZ[i - 1] - integralNZ[i - 258 - 1];\n\t\t}\n\t}\n\n\treturn { integral, integralNZ };\n}\n\n// BoxBlur based on integral images, whoop whoop\nexport function blurData(im: DataPictureIntegral, radius: number): DataPictureIntegral {\n\tif (radius < 0 || radius === im.radius) return im;\n\tim.radius = radius;\n\tconst s = 258;\n\tconst { integral, integralNZ } = im.integral;\n\tfor (let y = 1; y < s; y++) {\n\t\tfor (let x = 1; x < s; x++) {\n\t\t\tif (!im.raw[s * y + x]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst rx = Math.min(radius, x - 1, s - 1 - x);\n\t\t\tconst ry = Math.min(radius, y - 1, s - 1 - y);\n\t\t\tconst i1 = s * (y - ry - 1) + x;\n\t\t\tconst i2 = s * (y + ry) + x;\n\n\t\t\tconst ANZ = integralNZ[i1 - rx - 1];\n\t\t\tconst BNZ = integralNZ[i1 + rx];\n\t\t\tconst CNZ = integralNZ[i2 - rx - 1];\n\t\t\tconst DNZ = integralNZ[i2 + rx];\n\t\t\tconst sumNZ = ANZ + DNZ - BNZ - CNZ; // amount of non Zero values\n\n\t\t\tconst A = integral[i1 - rx - 1];\n\t\t\tconst B = integral[i1 + rx];\n\t\t\tconst C = integral[i2 - rx - 1];\n\t\t\tconst D = integral[i2 + rx];\n\t\t\tconst sum = A + D - B - C;\n\n\t\t\t// const rr = (2 * rx + 1) * (2 * ry + 1)\n\t\t\tim.raw[y * s + x] = sum / sumNZ;\n\t\t}\n\t}\n\treturn im;\n}\n\nexport function RGBtoHEX(rgb: number): string {\n\tconst r = (rgb >> 0) & 255;\n\tconst g = (rgb >> 8) & 255;\n\tconst b = (rgb >> 16) & 255;\n\tlet rs = r.toString(16);\n\tlet gs = g.toString(16);\n\tlet bs = b.toString(16);\n\trs = rs.length === 2 ? rs : '0' + rs;\n\tgs = gs.length === 2 ? gs : '0' + gs;\n\tbs = bs.length === 2 ? bs : '0' + bs;\n\treturn '#' + rs + gs + bs;\n}\n\nexport function RGBAtoHEX(rgba: number): string {\n\tconst r = (rgba >> 0) & 255;\n\tconst g = (rgba >> 8) & 255;\n\tconst b = (rgba >> 16) & 255;\n\tconst a = (rgba >> 24) & 255;\n\tlet rs = r.toString(16);\n\tlet gs = g.toString(16);\n\tlet bs = b.toString(16);\n\tlet as = a.toString(16);\n\trs = rs.length === 2 ? rs : '0' + rs;\n\tgs = gs.length === 2 ? gs : '0' + gs;\n\tbs = bs.length === 2 ? bs : '0' + bs;\n\tas = as.length === 2 ? as : '0' + as;\n\treturn '#' + rs + gs + bs + as;\n}\n\nexport function HEXtoRGBA(c: string): number {\n\tif (c[0] === '#') {\n\t\tif (c.length === 4) return +('0xff' + c[3] + c[3] + c[2] + c[2] + c[1] + c[1]);\n\t\tif (c.length === 7) return +('0xff' + c[5] + c[6] + c[3] + c[4] + c[1] + c[2]);\n\t\tif (c.length === 9) return +('0x' + c[7] + c[8] + c[5] + c[6] + c[3] + c[4] + c[1] + c[2]);\n\t}\n\n\tif (window.wxlogging) {\n\t\tconsole.log('wrong color format', c);\n\t}\n\treturn 0;\n}\n\n// json loader helper\nexport async function fetchJson(url: RequestInfo) {\n\treturn (await fetch(url)).json();\n}\n\nexport function createEl(tagName: string, className = '', container?: HTMLElement) {\n\tconst el = document.createElement(tagName); // Object.assign(document.createElement(tagName), { className });\n\tel.className = className;\n\tcontainer && container.appendChild?.(el);\n\treturn el;\n}\n\nexport function mixColor(c1: number, c2: number, t: number): number {\n\tconst r1 = (c1 >> 0) & 255;\n\tconst g1 = (c1 >> 8) & 255;\n\tconst b1 = (c1 >> 16) & 255;\n\tconst a1 = c1 >>> 24;\n\n\tconst r2 = (c2 >> 0) & 255;\n\tconst g2 = (c2 >> 8) & 255;\n\tconst b2 = (c2 >> 16) & 255;\n\tconst a2 = c2 >>> 24;\n\n\tconst r = r1 + t * (r2 - r1);\n\tconst g = g1 + t * (g2 - g1);\n\tconst b = b1 + t * (b2 - b1);\n\tconst a = a1 + t * (a2 - a1);\n\treturn r | (g << 8) | (b << 16) | (a << 24);\n}\n\nexport function createLevels(min: number, max: number, n: number): number[] {\n\t// create 10 levels from min to max\n\tconst levels: number[] = [];\n\tfor (let i = 0; i < n; ++i) {\n\t\tlevels.push((i * (max - min)) / (n - 1) + min);\n\t}\n\treturn levels;\n}\n", "import { HEXtoRGBA, RGBtoHEX, makeConverter, getColorSchemes, mixColor, createLevels } from './wxtools';\nimport { Converter, ColorStyleStrict } from './wxtools';\n// import type { Converter } from './wxtools';\n\nfunction clamp(val: number, min: number, max: number) {\n\treturn val > max ? max : val < min ? min : val;\n}\n\ninterface Tick {\n\tdata: number;\n\tdataString: string;\n\tcolor: string;\n\tpos: number;\n}\n\nexport class RawCLUT {\n\tlevelIndex: Uint32Array;\n\tcolorsI: Uint32Array;\n\tDataToStyle: Converter;\n\tDataToKnots?: Converter;\n\tticks: Tick[];\n\tconstructor(style: ColorStyleStrict, dUnits: string, [dMin, dMax]: [number, number], vector: boolean) {\n\t\tconst dDif = dMax - dMin;\n\t\tthis.levelIndex = new Uint32Array(65536);\n\t\tthis.colorsI = new Uint32Array(65536);\n\t\tconst levels: number[] = [];\n\n\t\tthis.DataToStyle = makeConverter(dUnits, style.units, style.extraUnits);\n\t\tif (this.DataToStyle.trivial) style.units = dUnits; // in case Style doesn't contain unit or incorrect units, use dUnits\n\t\tvector && (this.DataToKnots = makeConverter(dUnits, 'knot')); // for `barbs` and `arrows` fonts\n\t\tconst styleValToData = makeConverter(style.units, dUnits, style.extraUnits);\n\t\tconst styleValToRAW = (x: number) => ~~(65535 * clamp((styleValToData(x) - dMin) / (dMax - dMin), 0, 1));\n\n\t\t// A MAGIC with colors and levels is happening here\n\t\tif (Array.isArray(style.colorMap)) {\n\t\t\tstyle.colorMap.sort((a: [number, string], b: [number, string]) => (a[0] < b[0] ? -1 : a[0] > b[0] ? 1 : 0));\n\t\t\tfor (const [val] of style.colorMap) {\n\t\t\t\t// convert style ticks to data ticks, data ticks to indexes [0-65535]\n\t\t\t\tlevels.push(styleValToRAW(val));\n\t\t\t}\n\t\t} else {\n\t\t\t// check levels\n\t\t\tif (!style.levels) {\n\t\t\t\tstyle.levels = createLevels(this.DataToStyle(dMin), this.DataToStyle(dMax), 10);\n\t\t\t}\n\t\t\tstyle.levels.sort((a: number, b: number) => (a < b ? -1 : a > b ? 1 : 0));\n\n\t\t\tif (!style.colors) {\n\t\t\t\tconst colorSchemes = getColorSchemes();\n\t\t\t\t// try to use colors array first. if nothig here create it from a scheme\n\t\t\t\tif (style.colorScheme && style.colorScheme in colorSchemes) {\n\t\t\t\t\tstyle.colors = colorSchemes[style.colorScheme];\n\t\t\t\t} else {\n\t\t\t\t\t// if there is no scheme create random scheme\n\t\t\t\t\tstyle.colors = colorSchemes.wb;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const val of style.levels) {\n\t\t\t\t// convert style ticks to data ticks, data ticks to indexes [0-65535]\n\t\t\t\tlevels.push(styleValToRAW(val));\n\t\t\t}\n\t\t}\n\n\t\tconst lSize = 65536;\n\t\tconst legend = createLegend(lSize, style);\n\t\tthis.ticks = legend.ticks;\n\t\tconst lMin = legend.ticks[0].data;\n\t\tconst lMax = legend.ticks[legend.ticks.length - 1].data;\n\t\tconst lDif = lMax - lMin;\n\t\tfor (let i = 0; i < 65536; ++i) {\n\t\t\tconst d = (dDif * i) / 65535 + dMin; // index -> data\n\t\t\tconst l = this.DataToStyle(d); // data -> style units\n\t\t\tconst li = Math.round(((lSize - 1) * (l - lMin)) / lDif); // style units -> legend index\n\t\t\tif (li <= 0) {\n\t\t\t\tthis.colorsI[i] = style.showBelowMin ? legend.colors[0] : 0;\n\t\t\t} else if (li >= lSize) {\n\t\t\t\tthis.colorsI[i] = style.showAboveMax ? legend.colors[lSize - 1] : 0;\n\t\t\t} else {\n\t\t\t\tthis.colorsI[i] = legend.colors[li];\n\t\t\t}\n\t\t}\n\n\t\tthis.colorsI[0] = 0;\n\n\t\t// fill up 'levelIndex'\n\t\t// fill up left part of levelIndex (before the first level)\n\t\tfor (let i = 0; i < levels[0]; ++i) {\n\t\t\tthis.levelIndex[i] = 0;\n\t\t}\n\t\tfor (let li = 0; li < levels.length - 1; li++) {\n\t\t\tfor (let i = levels[li]; i < levels[li + 1] + 1; ++i) {\n\t\t\t\tthis.levelIndex[i] = li;\n\t\t\t}\n\t\t}\n\t\t// fill up the rest of levelIndex after the last colorMap value\n\t\tfor (let i = levels[levels.length - 1]; i < 65536; ++i) {\n\t\t\tthis.levelIndex[i] = levels.length - 1;\n\t\t}\n\t} // constructor\n} // class CLUT\n\nfunction numToString(n: number) {\n\tif (n !== 0 && -0.1 < n && n < 0.1) return n.toExponential(2);\n\tconst ns = n.toString();\n\tif (ns.split('.')[1]?.length > 2) return n.toFixed(2);\n\treturn ns;\n}\n\nexport interface Legend {\n\tsize: number;\n\tshowBelowMin: boolean;\n\tshowAboveMax: boolean;\n\tunits: string;\n\tcolors: Uint32Array;\n\tticks: Tick[];\n}\n\nexport function createLegend(size: number, style: ColorStyleStrict): Legend {\n\tconst legend: Legend = {\n\t\tsize,\n\t\tshowBelowMin: style.showBelowMin,\n\t\tshowAboveMax: style.showAboveMax,\n\t\tunits: style.units,\n\t\tcolors: new Uint32Array(size),\n\t\tticks: [],\n\t};\n\tconst { colorMap, levels, colors } = style;\n\tconst gradient = style.fill !== 'solid';\n\n\t// use colorMap if presented\n\tif (colorMap) {\n\t\tconst dMin = colorMap[0][0];\n\t\tconst dDif = colorMap[colorMap.length - 1][0] - dMin;\n\t\t// fill 'ticks'\n\t\tfor (const [data, color] of colorMap) {\n\t\t\tconst pos = ~~(((data - dMin) / dDif) * (size - 1));\n\t\t\tconst tick: Tick = { data, dataString: numToString(data), color, pos };\n\t\t\tlegend.ticks.push(tick);\n\t\t}\n\n\t\t// if (style.fill !== 'none') {\n\t\tfor (let li = 0; li < colorMap.length - 1; li++) {\n\t\t\tconst pos0 = legend.ticks[li].pos;\n\t\t\tconst pos1 = legend.ticks[li + 1].pos;\n\t\t\tconst c0 = HEXtoRGBA(colorMap[li][1]);\n\t\t\tconst c1 = gradient ? HEXtoRGBA(colorMap[li + 1][1]) : 0;\n\t\t\tfor (let i = pos0; i < pos1; ++i) {\n\t\t\t\tlegend.colors[i] = gradient ? mixColor(c0, c1, (i - pos0) / (pos1 - pos0)) : c0;\n\t\t\t}\n\t\t}\n\t\tlegend.colors[size - 1] = HEXtoRGBA(colorMap[colorMap.length - 1][1]);\n\t\t// }\n\t\treturn legend;\n\t}\n\n\tif (!colors || !levels) return legend;\n\n\tlet c0 = 0;\n\tlet c1 = 0;\n\tlet ci = -1;\n\tfor (let i = 0; i < size; ++i) {\n\t\tconst cf = (i * (colors.length - 1)) / size;\n\t\tif (ci !== ~~cf) {\n\t\t\tci = ~~cf;\n\t\t\tc0 = HEXtoRGBA(colors[ci]);\n\t\t\tc1 = colors.length > ci + 1 ? HEXtoRGBA(colors[ci + 1]) : c0;\n\t\t}\n\t\tlegend.colors[i] = gradient ? mixColor(c0, c1, cf - ci) : c0;\n\t}\n\tlegend.colors[size - 1] = HEXtoRGBA(colors[colors.length - 1]);\n\t// fill 'ticks'\n\tconst dMin = levels[0];\n\tconst dMul = (size - 1) / (levels[levels.length - 1] - dMin);\n\n\tfor (const data of levels) {\n\t\tconst pos = ~~((data - dMin) * dMul);\n\t\tconst tick: Tick = { data, dataString: numToString(data), color: RGBtoHEX(legend.colors[pos]), pos };\n\t\tlegend.ticks.push(tick);\n\t}\n\n\treturn legend;\n}\n", "const tileSize = 256;\nconst initialResolution = (2 * Math.PI * 6378137) / tileSize;\nconst originShift = (2 * Math.PI * 6378137) / 2;\n\n// LatLonToMeters converts given lat/lon in WGS84 Datum to XY in Spherical Mercator EPSG:900913\nfunction LatLonToMeters(lat: number, lon: number): [number, number] {\n\tlet x = (lon * originShift) / 180;\n\tlet y = Math.log(Math.tan(((90 + lat) * Math.PI) / 360)) / (Math.PI / 180);\n\ty = (y * originShift) / 180;\n\treturn [x, y];\n}\n\n// MetersToLatLon converts XY point from Spherical Mercator EPSG:900913 to lat/lon in WGS84 Datum\nfunction MetersToLatLon(x: number, y: number): [number, number] {\n\tlet lon = (x / originShift) * 180;\n\tlet lat = (y / originShift) * 180;\n\tlat = (180 / Math.PI) * (2 * Math.atan(Math.exp((lat * Math.PI) / 180)) - Math.PI / 2);\n\treturn [lat, lon];\n}\n\n// PixelsToMeters converts Pixel coordinates in given zoom level of pyramid to EPSG:900913\nfunction PixelsToMeters(px: number, py: number, zoom: number): [number, number] {\n\tconst res = Resolution(zoom);\n\tconst x = px * res - originShift;\n\tconst y = py * res - originShift;\n\treturn [x, y];\n}\n\n// MetersToPixels converts EPSG:900913 to Pixel coordinates in given zoom level\nfunction MetersToPixels(x: number, y: number, zoom: number): [number, number] {\n\tconst res = Resolution(zoom);\n\tconst px = (x + originShift) / res;\n\tconst py = (y + originShift) / res;\n\treturn [px, py];\n}\n\n// Resolution calculates the resolution (meters/Pixel) for given zoom level (measured at Equator)\nfunction Resolution(zoom: number): number {\n\treturn initialResolution / Math.pow(2, zoom);\n}\n\n// LatLonToPixels converts given lat/lon in WGS84 Datum to Pixel coordinates in given zoom level\nexport function LatLonToPixels(lat: number, lon: number, zoom: number): [number, number] {\n\tconst [x, y] = LatLonToMeters(lat, lon);\n\treturn MetersToPixels(x, y, zoom);\n}\n\n// PixelsToLatLon converts Pixel coordinates in given zoom level to lat/lon in WGS84 Datum\nexport function PixelsToLatLon(px: number, py: number, zoom: number): [number, number] {\n\tconst [x, y] = PixelsToMeters(px, py, zoom);\n\treturn MetersToLatLon(x, y);\n}\n\n// PixelsToLonLat converts Pixel coordinates in given zoom level to lat/lon in WGS84 Datum\nexport function PixelsToLonLat(px: number, py: number, zoom: number): [number, number] {\n\tconst [lat, lon] = MetersToLatLon(...PixelsToMeters(px, py, zoom));\n\treturn [lon, -lat];\n}\n\nexport function coordToPixel(x: number, y: number) {\n\treturn [x * tileSize, y * tileSize];\n}\n", "import { blurData, RGBtoHEX, HEXtoRGBA, createEl } from './wxtools';\nimport { DataPicture, DataPictureIntegral, ColorStyleStrict } from './wxtools';\nimport { RawCLUT } from './RawCLUT';\nimport { coordToPixel, PixelsToLonLat } from './mercator';\n\ninterface Coords {\n\tz: number;\n\tx: number;\n\ty: number;\n}\n\nfunction subDataDegree(data: DataPicture, subCoords?: Coords): DataPicture {\n\tif (!subCoords) return data;\n\tconst s = 0.9999999 / Math.pow(2, subCoords.z); // a subsize of a tile // 0.99999 - a dirty trick to never cross the bottom and rigth edges of the original tile.\n\tconst sx = subCoords.x * 256 * s; // upper left point of a subtile\n\tconst sy = subCoords.y * 256 * s;\n\tconst subData: DataPicture = { raw: new Uint16Array(258 * 258), dmin: data.dmin, dmax: data.dmax, dmul: data.dmul };\n\tconst { raw } = subData;\n\tfor (let y = -1, i = 0; y <= 256; y++) {\n\t\tconst dy = sy + y * s; // `y` projection of the subtile onto the original tile\n\t\tconst dyi = Math.floor(dy); // don't use ~~ because of negatives on left and upper borders\n\t\tconst dyt = dy - dyi; // [0, 1] - `y` interpolation coeff\n\t\tfor (let x = -1; x <= 256; x++, i++) {\n\t\t\tconst dx = sx + x * s;\n\t\t\tconst dxi = Math.floor(dx); // don't use ~~ because of negatives\n\t\t\tconst dxt = dx - dxi;\n\t\t\tconst di = dxi + 1 + (dyi + 1) * 258; // data index\n\t\t\t// interpolation inside a rectangular\n\t\t\t// a----b\n\t\t\t// |    |\n\t\t\t// |    |\n\t\t\t// c----d\n\t\t\t// interpolation inside a rectangular\n\t\t\tlet a = data.raw[di]; // upper left corner\n\t\t\tlet b = data.raw[di + 1]; // upper right\n\t\t\tlet c = data.raw[di + 258]; // lower left\n\t\t\tlet d = data.raw[di + 258 + 1]; // lower right\n\n\t\t\t// 16 possible variants for a,b,c,d != 0 ( != NaN)\n\t\t\tconst sq = (a ? 1 : 0) | (b ? 2 : 0) | (c ? 4 : 0) | (d ? 8 : 0);\n\t\t\tswitch (sq) {\n\t\t\t\tcase 0b0000:\n\t\t\t\t\traw[i] = 0; // NaN\n\t\t\t\t\tcontinue;\n\t\t\t\tcase 0b0001: // only a != NaN\n\t\t\t\t\traw[i] = a;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase 0b0010: // only b != NaN\n\t\t\t\t\traw[i] = b;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase 0b0011: // a, b != NaN\n\t\t\t\t\tc = a;\n\t\t\t\t\td = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0b0100: // ... etc\n\t\t\t\t\traw[i] = c;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase 0b0101:\n\t\t\t\t\tb = a;\n\t\t\t\t\td = c;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0b0110:\n\t\t\t\t\td = (b + c) >> 1;\n\t\t\t\t\ta = d;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0b0111:\n\t\t\t\t\td = (b + c) >> 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0b1000:\n\t\t\t\t\traw[i] = d;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase 0b1001:\n\t\t\t\t\tb = (a + d) >> 1;\n\t\t\t\t\tc = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0b1010:\n\t\t\t\t\ta = b;\n\t\t\t\t\tc = d;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0b1011:\n\t\t\t\t\tc = (a + d) >> 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0b1100:\n\t\t\t\t\ta = c;\n\t\t\t\t\tb = d;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0b1101:\n\t\t\t\t\tb = (a + d) >> 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0b1110:\n\t\t\t\t\ta = (b + c) >> 1;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ta = data.dmin + data.dmul * a;\n\t\t\tb = data.dmin + data.dmul * b;\n\t\t\tc = data.dmin + data.dmul * c;\n\t\t\td = data.dmin + data.dmul * d;\n\n\t\t\t// 2) bilinear\n\t\t\tconst u = linearInterpDegree(a, b, dxt); // upper line\n\t\t\tconst l = linearInterpDegree(c, d, dxt); // lower line\n\t\t\traw[i] = (linearInterpDegree(u, l, dyt) - data.dmin) / data.dmul;\n\t\t\tif (raw[i] === 0) raw[i] = 1; // 0 is NaN, we don't need NaN here!\n\t\t} // for x\n\t} // for y\n\treturn subData;\n}\n\nfunction linearInterpDegree(start: number, end: number, amount: number): number {\n\tconst shortestAngle = ((((end - start) % 360) + 540) % 360) - 180;\n\treturn (start + shortestAngle * amount + 360) % 360;\n}\n\nfunction subData(data: DataPicture, subCoords?: Coords): DataPicture {\n\tif (!subCoords) return data;\n\tconst s = 0.9999999 / Math.pow(2, subCoords.z); // a subsize of a tile // 0.99999 - a dirty trick to never cross the bottom and rigth edges of the original tile.\n\tconst sx = subCoords.x * 256 * s; // upper left point of a subtile\n\tconst sy = subCoords.y * 256 * s;\n\tconst subData: DataPicture = { raw: new Uint16Array(258 * 258), dmin: data.dmin, dmax: data.dmax, dmul: data.dmul };\n\tconst { raw } = subData;\n\tfor (let y = -1, i = 0; y <= 256; y++) {\n\t\tconst dy = sy + y * s; // `y` projection of the subtile onto the original tile\n\t\tconst dyi = Math.floor(dy); // don't use `~~` because of negatives on left and upper borders\n\t\tconst dyt = dy - dyi; // [0, 1] - `y` interpolation coeff\n\t\tfor (let x = -1; x <= 256; x++, i++) {\n\t\t\tconst dx = sx + x * s;\n\t\t\tconst dxi = Math.floor(dx); // don't use ~~ because of negatives\n\t\t\tconst dxt = dx - dxi;\n\t\t\tconst di = dxi + 1 + (dyi + 1) * 258; // data index\n\n\t\t\t// interpolation inside a rectangular\n\t\t\tconst a = data.raw[di]; // upper left corner\n\t\t\tconst b = data.raw[di + 1]; // upper right\n\t\t\tconst c = data.raw[di + 258]; // lower left\n\t\t\tconst d = data.raw[di + 258 + 1]; // lower right\n\n\t\t\t// 0       1\n\t\t\t//  a --- b   default version            a --- b    flipped version\n\t\t\t//  |   / |                              | \\   |\n\t\t\t//  | / x | - pyt                        |   \\ |\n\t\t\t//  c --- d                              c --- d\n\t\t\t// 2    |  3\n\t\t\t//     pxt\n\t\t\t//\n\t\t\t// x - point to interpolate\n\n\t\t\t// 16 possible variants for a,b,c,d != 0 ( != NaN)\n\t\t\tconst sq = (a ? 1 : 0) | (b ? 2 : 0) | (c ? 4 : 0) | (d ? 8 : 0);\n\t\t\tswitch (sq) {\n\t\t\t\tcase 0b0111: // -cba   -default version\n\t\t\t\t\traw[i] = dxt + dyt < 1 ? dxt * (b - a) + dyt * (c - a) + a : 0;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase 0b1110: // dcb-   -default version\n\t\t\t\t\traw[i] = dxt + dyt < 1 ? 0 : dxt * (d - c) + dyt * (d - b) + b + c - d;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase 0b1011: // d-ba   - flipped version\n\t\t\t\t\traw[i] = dyt < dxt ? (1 - dxt) * (a - b) + dyt * (d - b) + b : 0;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase 0b1101: // dc-a   - flipped version\n\t\t\t\t\traw[i] = dyt < dxt ? 0 : (1 - dxt) * (c - d) + dyt * (c - a) + a + d - c;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase 0b1111: // dcba   -default version\n\t\t\t\t\traw[i] = dxt + dyt < 1 ? dxt * (b - a) + dyt * (c - a) + a : dxt * (d - c) + dyt * (d - b) + b + c - d;\n\t\t\t\t\tcontinue;\n\t\t\t\tdefault:\n\t\t\t\t\traw[i] = 0;\n\t\t\t}\n\t\t} // for x\n\t} // for y\n\treturn subData;\n}\n\ninterface TileEl extends HTMLElement {\n\twxtile?: WxTile;\n}\n\nexport interface TileCreateParams {\n\tlayer: Layer;\n\tcoords: Coords;\n\tdone: () => void;\n}\n\nfunction makeBobx(coords: Coords): BoundaryMeta {\n\tconst [px, py] = coordToPixel(coords.x, coords.y);\n\tconst [west, north] = PixelsToLonLat(px, py, coords.z);\n\tconst [east, south] = PixelsToLonLat(px + 256, py + 256, coords.z);\n\treturn { west, north, east, south };\n}\n\nexport function TileCreate({ layer, coords, done }: TileCreateParams): TileEl {\n\tconst tileEl: TileEl = createEl('div', 'leaflet-tile s-tile');\n\n\tif (layer.dataSource) {\n\t\ttileEl.wxtile = new WxTile({ layer, coords, tileEl });\n\t\ttileEl.wxtile._load().then((wxtile) => {\n\t\t\twxtile.draw(); // (**) call draw at first loading time only. Otherwise it is drawn manually after all tiles are loaded\n\t\t\tdone(); // done is used after create (to appear on map), not after reload (it is on the map already).\n\t\t});\n\t} else {\n\t\t// the layer hasn't been initilized yet, nothing to do.\n\t\t// this happens due to lazy setup. layer.reload() is fired when ready and recreates all tiles.\n\t\tsetTimeout(done);\n\t}\n\n\treturn tileEl;\n}\n\ntype LoadDataFunc = (URL: string) => Promise<DataPicture>;\n\nexport interface VariableMeta {\n\t[name: string]: {\n\t\tunits: string;\n\t\tmin: number;\n\t\tmax: number;\n\t};\n}\n\nexport interface BoundaryMeta {\n\twest: number;\n\tnorth: number;\n\teast: number;\n\tsouth: number;\n}\nexport interface AllBoundariesMeta {\n\tboundariesnorm: BoundaryMeta;\n\tboundaries180: BoundaryMeta[];\n\tboundaries360: BoundaryMeta[];\n}\n\nexport interface Meta {\n\tvariables: string[];\n\tvariablesMeta: VariableMeta;\n\tmaxZoom: number;\n\ttimes: string[];\n\tboundaries?: AllBoundariesMeta;\n}\nexport interface DataSource {\n\tserverURI: string; // server to fetch data from\n\text: string; // png / webp (default) - wxtilesplitter output format\n\tdataset: string; // dataset of the dataset\n\tvariables: string[]; // variable(s) to be used for the layer rendering\n\tname: string; // attribute of the dataSource to be used externally\n\tstyleName: string; // The name of the style (from styles.json) to apply for the layer\n\tunits: string;\n\tmeta: Meta;\n\tbaseURL: string;\n}\n\ninterface Layer {\n\tstyle: ColorStyleStrict;\n\tloadData: LoadDataFunc;\n\tdataSource: DataSource;\n\tvector: boolean;\n\tclut: RawCLUT;\n}\n\ninterface SLinePoint {\n\tx: number;\n\ty: number;\n}\n\ntype SLine = SLinePoint[];\n\nexport class WxTile {\n\tlayer: Layer;\n\tcoords: Coords;\n\tcanvasFill: HTMLCanvasElement;\n\tcanvasSlines: HTMLCanvasElement;\n\tcanvasVector: HTMLCanvasElement;\n\tcanvasFillCtx: CanvasRenderingContext2D;\n\tcanvasSlinesCtx: CanvasRenderingContext2D;\n\tcanvasVectorCtx: CanvasRenderingContext2D;\n\tdata: DataPicture[] = [];\n\tsLines: SLine[] = [];\n\timData: ImageData | null = null;\n\n\tconstructor({ layer, coords, tileEl }: { layer: Layer; coords: Coords; tileEl: TileEl }) {\n\t\tthis.coords = coords;\n\t\tthis.layer = layer;\n\n\t\t// create <canvas> elements for drawing with tile's methods\n\t\tthis.canvasFill = createEl('canvas', 's-tile canvas-fill', tileEl) as HTMLCanvasElement;\n\t\tthis.canvasSlines = createEl('canvas', 's-tile canvas-slines', tileEl) as HTMLCanvasElement;\n\t\tthis.canvasVector = this.canvasFill;\n\n\t\tthis.canvasFill.width = this.canvasFill.height = this.canvasSlines.width = this.canvasSlines.height = 256;\n\n\t\tfunction getCtx(el: HTMLCanvasElement) {\n\t\t\tconst ctx = el.getContext('2d');\n\t\t\tif (!ctx) throw 'error';\n\t\t\treturn ctx;\n\t\t}\n\t\tthis.canvasFillCtx = getCtx(this.canvasFill);\n\t\tthis.canvasSlinesCtx = getCtx(this.canvasSlines);\n\t\tthis.canvasVectorCtx = this.canvasFillCtx;\n\t}\n\n\tdraw() {\n\t\tif (!this.data.length) {\n\t\t\tthis.canvasFillCtx.clearRect(0, 0, 256, 256); // In animation through time it can become empty\n\t\t\tthis.canvasSlinesCtx.clearRect(0, 0, 256, 256); // so it needs to be cleared (fucg bug231)\n\t\t\treturn;\n\t\t}\n\n\t\tthis._drawFillAndIsolines();\n\t\tthis._drawVector();\n\t\tthis._drawDegree();\n\t\tthis._drawStaticSlines();\n\t} // draw\n\n\tclearSLinesCanvas() {\n\t\tthis.canvasSlinesCtx.clearRect(0, 0, 256, 256);\n\t\t// this.canvasSlines.getContext('2d').clearRect(0, 0, 256, 256);\n\t} // clearSLinesCanvas\n\n\tdrawSLines(timeStemp: number) {\n\t\t// 'timeStemp' is a time tick given by the browser's scheduller\n\t\tif (this.sLines.length === 0) return;\n\n\t\tconst ctx = this.canvasSlinesCtx; // .getContext('2d');\n\t\tctx.clearRect(0, 0, 256, 256);\n\t\tif (this.layer.style.streamLineColor === 'none') {\n\t\t\tthis.sLines = []; // this can happen if a new style was set up after the layer was loaded.\n\t\t\treturn;\n\t\t}\n\t\tconst baseColor = this.layer.style.streamLineColor.substr(0, 7);\n\t\ttimeStemp = timeStemp >> 7;\n\t\tfor (let i = 0; i < this.sLines.length; ++i) {\n\t\t\tconst sLine = this.sLines[i];\n\t\t\tconst sSize = sLine.length - 1;\n\t\t\t// TODO:\n\t\t\t// seed - is the most opaque piece\n\t\t\t// let seed = (timeStemp + sLine[0].x + sLine[0].y) % (sSize * 2); // to make more chaos // regular visual patterns make animation less smooth\n\t\t\tlet seed = (timeStemp + (1 + sLine[0].x) * (1 + sLine[0].y)) % 30;\n\t\t\tfor (let k = 0; k < sSize; ++k) {\n\t\t\t\tconst p0 = sLine[k];\n\t\t\t\tconst p1 = sLine[k + 1];\n\t\t\t\t// if (pt < k) pt += sSize;\n\t\t\t\tlet t = 1 - (seed - k) / sSize;\n\t\t\t\tif (t < 0 || t > 1) t = 0;\n\t\t\t\tconst col = (~~(t * 255)).toString(16);\n\t\t\t\tctx.strokeStyle = baseColor + (col.length < 2 ? '0' + col : col);\n\t\t\t\tconst w = 1 + ~~((1.2 - t) * 5);\n\t\t\t\tctx.lineWidth = w;\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(p0.x, p0.y);\n\t\t\t\tctx.lineTo(p1.x, p1.y);\n\t\t\t\tctx.stroke();\n\t\t\t}\n\t\t}\n\t}\n\n\t// x, y - pixel on tile\n\tgetData({ x, y }) {\n\t\tif (!this.data.length) return;\n\t\tconst raw = this.data[0].raw[(y + 1) * 258 + (x + 1)];\n\t\treturn { raw, data: this.data[0].dmin + this.data[0].dmul * raw };\n\t} // getData\n\n\tasync _load() {\n\t\tconst { coords, layer } = this;\n\t\tconst { boundaries } = layer.dataSource.meta;\n\t\tif (boundaries?.boundaries180) {\n\t\t\tconst bbox = makeBobx(coords);\n\t\t\tconst rectIntersect = (b: BoundaryMeta) => !(bbox.west > b.east || b.west > bbox.east || bbox.south > b.north || b.south > bbox.north);\n\t\t\tif (!boundaries.boundaries180.some(rectIntersect)) {\n\t\t\t\tthis.data = [];\n\t\t\t\tthis.imData = null;\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\n\t\tconst { upCoords, subCoords } = this._splitCoords(coords);\n\n\t\tconst URLs = this._coordsToURLs(upCoords);\n\n\t\tlet data: DataPicture[] = [];\n\t\ttry {\n\t\t\tdata = await Promise.all(URLs.map(layer.loadData));\n\t\t} catch (e) {\n\t\t\tthis.data = [];\n\t\t\tthis.imData = null;\n\t\t\treturn this;\n\t\t}\n\n\t\tconst interpolator = layer.dataSource.units === 'degree' ? subDataDegree : subData;\n\t\t// combine 'subCoords' and 'blurRadius' in 'processor'\n\t\tconst processor = (d: DataPicture) => interpolator(blurData(<DataPictureIntegral>d, this.layer.style.blurRadius), subCoords);\n\t\tthis.data = data.map(processor); // preprocess all loaded data\n\t\tthis.imData = this.canvasFillCtx.createImageData(256, 256);\n\n\t\tif (this.layer.vector) {\n\t\t\tthis._vectorPrepare();\n\t\t\tthis._createSLines();\n\t\t}\n\n\t\treturn this;\n\t} // _load\n\n\t_splitCoords(coords: Coords): { upCoords: Coords; subCoords?: Coords } {\n\t\tconst zDif = coords.z - this.layer.dataSource.meta.maxZoom;\n\t\tif (zDif <= 0) {\n\t\t\treturn { upCoords: coords };\n\t\t}\n\t\tconst upCoords = { x: coords.x >>> zDif, y: coords.y >>> zDif, z: this.layer.dataSource.meta.maxZoom };\n\t\tconst subCoords = { x: coords.x & ((1 << zDif) - 1), y: coords.y & ((1 << zDif) - 1), z: zDif };\n\t\treturn { upCoords, subCoords };\n\t} // _splitCoords\n\n\t_coordsToURLs(upCoords: Coords): string[] {\n\t\tconst u = this.layer.dataSource.baseURL.replace('{z}', String(upCoords.z)).replace('{x}', String(upCoords.x)).replace('{y}', String(upCoords.y));\n\t\treturn this.layer.dataSource.variables.map((v: string) => u.replace('{var}', v));\n\t} // _coordsToURLs\n\n\t_vectorPrepare() {\n\t\tif (this.data.length !== 2) throw 'this.data !== 2';\n\t\t// fill data[0] with precalculated vectors' lengths.\n\t\tthis.data.unshift({ raw: new Uint16Array(258 * 258), dmin: 0, dmax: 0, dmul: 0 });\n\t\tconst [l, u, v] = this.data; // length, u, v components\n\t\tl.dmax = 1.42 * Math.max(-u.dmin, u.dmax, -v.dmin, v.dmax);\n\t\tl.dmul = (l.dmax - l.dmin) / 65535;\n\t\tfor (let i = 0; i < 258 * 258; ++i) {\n\t\t\tif (!u.raw[i] || !v.raw[i]) {\n\t\t\t\tl.raw[i] = 0;\n\t\t\t\tcontinue;\n\t\t\t} // NODATA\n\t\t\tconst _u = u.dmin + u.dmul * u.raw[i]; // unpack U data\n\t\t\tconst _v = v.dmin + v.dmul * v.raw[i]; // unpack V data\n\t\t\tl.raw[i] = Math.sqrt(_v * _v + _u * _u) / l.dmul; // pack data back to use the original rendering approach\n\t\t}\n\t} // _vectorPrepare\n\n\t_drawFillAndIsolines() {\n\t\tconst { imData } = this;\n\t\tif (!imData) throw '_drawFillAndIsolines: !imData';\n\n\t\tconst { canvasFillCtx } = this;\n\t\tcanvasFillCtx.clearRect(0, 0, 256, 256);\n\t\tconst im = new Uint32Array(imData.data.buffer); // a usefull representation of image's bytes (same memory)\n\t\tconst { raw } = this.data[0]; // scalar data\n\t\tconst { clut, style } = this.layer;\n\t\tconst { levelIndex, colorsI } = clut;\n\n\t\t// fill: none, gradient, solid\n\t\tif (style.fill !== 'none') {\n\t\t\tconst fillC = colorsI;\n\t\t\tfor (let y = 0, i = 0, di = 259; y < 256; ++y, di += 2) {\n\t\t\t\tfor (let x = 0; x < 256; ++x, ++i, ++di) {\n\t\t\t\t\tim[i] = fillC[raw[di]];\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tim.fill(0);\n\t\t}\n\n\t\tconst info: {\n\t\t\tx: number;\n\t\t\ty: number;\n\t\t\td: number;\n\t\t\tdr: number;\n\t\t\tdb: number;\n\t\t\tmli: number;\n\t\t}[] = []; // numbers on isolines\n\t\t// isolineColor: none, #bbaa88ff - \"solid color\", fill, inverted\n\t\tif (style.isolineColor !== 'none') {\n\t\t\tconst flatColor = style.isolineColor[0] === '#' ? HEXtoRGBA(style.isolineColor) : 0;\n\t\t\tfor (let y = 0, t = 0; y < 256; y += 1) {\n\t\t\t\tfor (let x = 0; x < 256; x += 1) {\n\t\t\t\t\tconst i = (y + 1) * 258 + (x + 1);\n\t\t\t\t\tconst d = raw[i]; // central data\n\t\t\t\t\tconst dr = raw[i + 1]; // right\n\t\t\t\t\tconst db = raw[i + 258]; // bottom\n\t\t\t\t\tif (!d || !dr || !db) continue; // do not check isoline for NaN pixels (0)\n\n\t\t\t\t\tconst lic = levelIndex[d]; // check level index aroud the current pixel\n\t\t\t\t\tconst lir = levelIndex[dr]; // check level index aroud the current pixel\n\t\t\t\t\tconst lib = levelIndex[db]; // check level index aroud the current pixel\n\t\t\t\t\tif (lic !== lir || lic !== lib) {\n\t\t\t\t\t\tconst mli = Math.max(lic, lir, lib); // max level index out of three possible\n\t\t\t\t\t\tconst md = Math.max(d, dr, db); // max data index out of three possible\n\t\t\t\t\t\tconst ii = y * 256 + x;\n\t\t\t\t\t\tswitch (style.isolineColor) {\n\t\t\t\t\t\t\tcase 'inverted':\n\t\t\t\t\t\t\t\tim[ii] = ~colorsI[md] | 0xff000000; // invert color and make alfa = 255\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'fill':\n\t\t\t\t\t\t\t\tim[ii] = colorsI[md] | 0xff000000; // make alfa = 255\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tim[ii] = flatColor;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} // switch isoline_style\n\t\t\t\t\t\tif (style.isolineText && !(++t % 255) && x > 20 && x < 235 && y > 20 && y < 235) {\n\t\t\t\t\t\t\tinfo.push({ x, y, d, dr, db, mli });\n\t\t\t\t\t\t}\n\t\t\t\t\t} // if isoline\n\t\t\t\t} // for x\n\t\t\t} // for y\n\t\t} // if (style.isolineColor != 'none')\n\n\t\tcanvasFillCtx.putImageData(imData, 0, 0);\n\n\t\t// drawing Info\n\t\tif (!info.length) {\n\t\t\tcanvasFillCtx.font = '1.1em Sans-serif';\n\t\t\tcanvasFillCtx.lineWidth = 2;\n\t\t\tcanvasFillCtx.strokeStyle = 'white'; // RGBtoHEX(p.c); // alfa = 255\n\t\t\tcanvasFillCtx.fillStyle = 'black';\n\t\t\tcanvasFillCtx.textAlign = 'center';\n\t\t\tcanvasFillCtx.textBaseline = 'middle';\n\t\t\tfor (const { x, y, d, dr, db, mli } of info) {\n\t\t\t\tconst val = this.layer.clut.ticks[mli].dataString; // select value from levels/colorMap\n\t\t\t\tconst angle = Math.atan2(d - dr, db - d); // rotate angle: we can use RAW d, dd, and dr for atan2!\n\t\t\t\tcanvasFillCtx.save();\n\t\t\t\tcanvasFillCtx.translate(x, y);\n\t\t\t\tcanvasFillCtx.rotate(angle < -1.57 || angle > 1.57 ? angle + 3.14 : angle); // so text is always up side up\n\t\t\t\tcanvasFillCtx.strokeText(val, 0, 0);\n\t\t\t\tcanvasFillCtx.fillText(val, 0, 0);\n\t\t\t\tcanvasFillCtx.restore();\n\t\t\t}\n\t\t} // if info.length\n\t} // drawIsolines\n\n\t_drawStaticSlines() {\n\t\t// 'timeStemp' is a time tick given by the browser's scheduller\n\t\tif (!this.sLines.length || !this.layer.style.streamLineStatic) return;\n\t\tconst { canvasSlinesCtx } = this;\n\t\tcanvasSlinesCtx.clearRect(0, 0, 256, 256);\n\t\tif (this.layer.style.streamLineColor === 'none') {\n\t\t\tthis.sLines = []; // this can happen if a new style was set up after the layer was loaded.\n\t\t\treturn;\n\t\t}\n\t\tcanvasSlinesCtx.lineWidth = 2;\n\t\tcanvasSlinesCtx.strokeStyle = this.layer.style.streamLineColor; // color\n\t\tcanvasSlinesCtx.beginPath();\n\t\tfor (let i = this.sLines.length; i--; ) {\n\t\t\tconst sLine = this.sLines[i];\n\t\t\tfor (let k = 0; k < sLine.length - 1; ++k) {\n\t\t\t\tconst p0 = sLine[k];\n\t\t\t\tconst p1 = sLine[k + 1];\n\t\t\t\tcanvasSlinesCtx.moveTo(p0.x, p0.y);\n\t\t\t\tcanvasSlinesCtx.lineTo(p1.x, p1.y);\n\t\t\t}\n\t\t}\n\t\tcanvasSlinesCtx.stroke();\n\t}\n\n\t_drawVector() {\n\t\tif (!this.layer.vector || !this.layer.clut.DataToKnots) return;\n\t\tif (!this.layer.style.vectorColor || this.layer.style.vectorColor === 'none') return;\n\t\tif (!this.layer.style.vectorType || this.layer.style.vectorType === 'none') return;\n\t\tif (this.data.length !== 3) throw 'this.data.length !== 3';\n\t\tconst [l, u, v] = this.data;\n\n\t\tconst { canvasVectorCtx } = this;\n\n\t\tswitch (this.layer.style.vectorType) {\n\t\t\tcase 'barbs':\n\t\t\t\tcanvasVectorCtx.font = '40px barbs';\n\t\t\t\tbreak;\n\t\t\tcase 'arrows':\n\t\t\t\tcanvasVectorCtx.font = '50px arrows';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcanvasVectorCtx.font = this.layer.style.vectorType;\n\t\t}\n\n\t\tcanvasVectorCtx.textAlign = 'center';\n\t\tcanvasVectorCtx.textBaseline = 'middle';\n\n\t\tconst addDegrees = this.layer.style.addDegrees ? 0.017453292519943 * this.layer.style.addDegrees : 0;\n\n\t\t// const zdif = Math.max(this.coords.z - this.layer.dataSource.meta.maxZoom, 0);\n\t\tconst gridStep = 32; //Math.min(2 ** (zdif + 5), 128);\n\t\tfor (let y = gridStep / 2; y < 256; y += gridStep) {\n\t\t\tfor (let x = gridStep / 2; x < 256; x += gridStep) {\n\t\t\t\tconst di = x + 1 + (y + 1) * 258;\n\t\t\t\tif (!l.raw[di]) continue; // NODATA\n\n\t\t\t\tconst ang = Math.atan2(u.dmin + u.raw[di] * u.dmul, v.dmin + v.raw[di] * v.dmul);\n\t\t\t\tconst vecLen = l.dmin + l.raw[di] * l.dmul;\n\n\t\t\t\tconst sm = this.layer.dataSource.variables[0].includes('current') ? 5 : 0.2; // arrows are longer for currents than wind\n\t\t\t\tconst vecCode = Math.min(this.layer.clut.DataToKnots(vecLen) * sm, 25 /* to fit .ttf */) + 65; /* A */\n\t\t\t\tconst vecChar = String.fromCharCode(vecCode);\n\t\t\t\tswitch (this.layer.style.vectorColor) {\n\t\t\t\t\tcase 'inverted':\n\t\t\t\t\t\tcanvasVectorCtx.fillStyle = RGBtoHEX(~this.layer.clut.colorsI[l.raw[di]]); // alfa = 255\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'fill':\n\t\t\t\t\t\tcanvasVectorCtx.fillStyle = RGBtoHEX(this.layer.clut.colorsI[l.raw[di]]); // alfa = 255\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tcanvasVectorCtx.fillStyle = this.layer.style.vectorColor; // put color directly from vectorColor\n\t\t\t\t\t\tbreak;\n\t\t\t\t} // switch isoline_style\n\n\t\t\t\tcanvasVectorCtx.save();\n\t\t\t\tcanvasVectorCtx.translate(x, y);\n\t\t\t\tcanvasVectorCtx.rotate(ang + addDegrees);\n\t\t\t\tcanvasVectorCtx.fillText(vecChar, 0, 0);\n\t\t\t\tcanvasVectorCtx.restore();\n\t\t\t} // for x\n\t\t} // for y\n\t} // _drawVector\n\n\t_drawDegree() {\n\t\tif (this.layer.dataSource.units !== 'degree') return;\n\n\t\tconst { canvasVectorCtx } = this;\n\n\t\tconst addDegrees = this.layer.style.addDegrees ? 0.017453292519943 * this.layer.style.addDegrees : 0;\n\n\t\tcanvasVectorCtx.font = '50px arrows';\n\t\tcanvasVectorCtx.textAlign = 'start';\n\t\tcanvasVectorCtx.textBaseline = 'alphabetic';\n\t\t// ctx.clearRect(0, 0, 256, 256);\n\t\tconst l = this.data[0];\n\t\tconst vecChar = 'L';\n\n\t\t// const zdif = Math.max(this.coords.z - this.layer.dataSource.meta.maxZoom, 0);\n\t\tconst gridStep = 32; //Math.min(2 ** (zdif + 5), 128);\n\t\tfor (let y = gridStep / 2; y < 256; y += gridStep) {\n\t\t\tfor (let x = gridStep / 2; x < 256; x += gridStep) {\n\t\t\t\tconst di = x + 1 + (y + 1) * 258;\n\t\t\t\tif (!l.raw[di]) continue; // NODATA\n\t\t\t\tconst angDeg = l.dmin + l.raw[di] * l.dmul + 180;\n\t\t\t\tconst ang = angDeg * 0.01745329251; // pi/180\n\t\t\t\tswitch (this.layer.style.vectorColor) {\n\t\t\t\t\tcase 'inverted':\n\t\t\t\t\t\tcanvasVectorCtx.fillStyle = RGBtoHEX(~this.layer.clut.colorsI[l.raw[di]]); // alfa = 255\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'fill':\n\t\t\t\t\t\tcanvasVectorCtx.fillStyle = RGBtoHEX(this.layer.clut.colorsI[l.raw[di]]); // alfa = 255\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tcanvasVectorCtx.fillStyle = this.layer.style.vectorColor; // put color directly from vectorColor\n\t\t\t\t\t\tbreak;\n\t\t\t\t} // switch isoline_style\n\n\t\t\t\tcanvasVectorCtx.save();\n\t\t\t\tcanvasVectorCtx.translate(x, y);\n\t\t\t\tcanvasVectorCtx.rotate(ang + addDegrees);\n\t\t\t\tcanvasVectorCtx.fillText(vecChar, 0, 0);\n\t\t\t\tcanvasVectorCtx.restore();\n\t\t\t} // for x\n\t\t} // for y\n\t} // _drawDegree\n\n\t_createSLines() {\n\t\tif (this.data.length !== 3) throw 'this.data.length !== 3';\n\t\tif (!this.layer.style.streamLineColor || this.layer.style.streamLineColor === 'none') return;\n\t\tconst factor = this.layer.style.streamLineSpeedFactor || 1;\n\n\t\t// idea is taken from the LIC (linear integral convolution) algorithm and the 'multipartical vector field visualisation'\n\t\tthis.sLines = []; // an array of stremllines. Each section of streamline represents a position and size of a particle.\n\t\t// Having the stream lines as precalculated trajectories makes an animation more predictable and (IMHO) representative.\n\t\t// Algorithm: use U and V as an increment to build a trajectory. To make trajectory more or less correct the algo\n\t\t// does 20 moc steps and stores the point into streamline (sLine).\n\t\t// Algo does two passes: forward and backward, to cope boundaries and improve visual effect.\n\t\tconst [l, u, v] = this.data;\n\t\tconst zdif = Math.max(this.coords.z - this.layer.dataSource.meta.maxZoom, 0);\n\t\tconst gridStep = Math.min(2 ** (zdif + 5), 128);\n\t\tconst steps = ~~(120 + zdif * 60);\n\t\tfor (let y = 0; y <= 256; y += gridStep) {\n\t\t\tfor (let x = 0; x <= 256; x += gridStep) {\n\t\t\t\tif (!l.raw[x + y * 258]) continue; // NODATA\n\t\t\t\tconst sLine: SLine = []; // streamline\n\t\t\t\tlet xf = x;\n\t\t\t\tlet yf = y;\n\t\t\t\tfor (let i = 0; i <= steps && xf >= 0 && xf <= 256 && yf >= 0 && yf <= 256; i++) {\n\t\t\t\t\t// forward\n\t\t\t\t\t!(i % (steps / 6)) && sLine.push({ x: ~~xf, y: ~~yf }); // push each 20-th point // 7 points max\n\t\t\t\t\tconst di = ~~xf + 1 + (~~yf + 1) * 258;\n\t\t\t\t\tif (!l.raw[di]) break; // NODATA\n\t\t\t\t\txf += (factor * (u.dmin + u.raw[di] * u.dmul)) / l.dmax;\n\t\t\t\t\tyf -= (factor * (v.dmin + v.raw[di] * v.dmul)) / l.dmax; // negative - due to Lat goes up but screen's coordinates go down\n\t\t\t\t} // for i forward\n\t\t\t\txf = x;\n\t\t\t\tyf = y;\n\t\t\t\tfor (let i = 1; i <= steps && xf >= 0 && xf <= 256 && yf >= 0 && yf <= 256; i++) {\n\t\t\t\t\t// backward // i = 1 becouse otherwise it produces the same first point hence visual artefact! 2 hours debugging!\n\t\t\t\t\t!(i % (steps / 6)) && sLine.unshift({ x: ~~xf, y: ~~yf }); // push each 20-th point // 6 points max\n\t\t\t\t\tconst di = ~~xf + 1 + (~~yf + 1) * 258;\n\t\t\t\t\tif (!l.raw[di]) break; // NODATA\n\t\t\t\t\txf -= (factor * (u.dmin + u.raw[di] * u.dmul)) / l.dmax;\n\t\t\t\t\tyf += (factor * (v.dmin + v.raw[di] * v.dmul)) / l.dmax; // negative - due to Lat goes up but screen's coordinates go down\n\t\t\t\t} // for i backward\n\t\t\t\tsLine.length > 2 && this.sLines.push(sLine);\n\t\t\t} // for x\n\t\t} // for y\n\t} // _createSLines\n} // tileFunctions\n", "// https://stackoverflow.com/questions/36471220/how-can-i-convert-a-uint8array-with-offset-into-an-int32array\n// tile.style.pointerEvents = `auto`; tile.addEventListener(`click`, function(e) {console.log(`X=` + e.offsetX + ` Y=` + e.offsetY + ` ` + coords);});\n\nimport { RawCLUT, createLegend } from './RawCLUT';\nimport { TileCreate } from './tile';\nimport { loadDataPictureCachedAbortable, fetchJson, RGBtoHEX, WxGetColorStyles, createEl } from './wxtools';\n// import { ColorStyles } from './wxtools';\n\n// this is a proto object for a L.GridLayer extending, so can't be a 'class'\n// interface WxGridLayerI {\n// \toptions: any;\n// \tinitializeLayer: any; // initialize\n\n// \t// Leaflet's calling this, don't use it directly!\n// \tcreateTile: any; // createTile\n\n// \tgetSetupCompletePromise: any;\n\n// \t// get all the information about tile and point it represents\n// \t// zoom - current zoom level\n// \t// latlng - pixel on the map\n// \tgetTile: any; // getTile\n\n// \tsetStyle: any; // setStyle\n\n// \t// string\n// \tgetStyle: any;\n\n// \t// string\n// \tgetStyleName: any;\n\n// \t// unixTime - ms since 00:00:00 UTC on 1 January 1970\n// \tsetTime: any; // setTime\n\n// \t// string\n// \tgetTime: any;\n\n// \t// Arra of strings (times)\n// \tgetTimes: any;\n\n// \t// check if data has been changed since last init\n// \tcheckDataChanged: any;\n\n// \t// usefull if data is changed on server (checkable with 'checkDataChanged')\n// \treloadData: any;\n\n// \tgetLegendData: any;\n\n// \tsetTimeAnimationMode: any;\n\n// \tunsetTimeAnimationMode: any;\n\n// \tgetMinMax: any;\n\n// \t_setUpDataSet: any; // _setUpDataSet\n\n// \t_updateMinMax: any;\n\n// \t_initializeEvents: any;\n\n// \t_checkZoom: any;\n\n// \t// onAdd is used in the leaflet library! so I renamed it.\n// \t_onAddL: any;\n\n// \t_onRemoveL: any;\n\n// \t_stopLoadingResetLoadDataFunc: any;\n\n// \t_checkAndStartSlinesAnimation: any;\n\n// \t_stopSlinesAnimation: any;\n\n// \t_getClosestTimeString: any; // _getClosestTimeString\n\n// \t_redrawTiles: any; // _redrawTiles\n\n// \t_reloadTiles: any; // _reloadTiles\n// } // WxGridLayerProto\n\nexport const WxGridLayerProto = {\n\tinitializeLayer({ dataSource, options = {}, lazy = true }) {\n\t\tif (window.wxlogging) {\n\t\t\tconsole.log('Creating a WxTile layer:' + JSON.stringify({ dataSource, options }));\n\t\t}\n\n\t\t// class constructor\n\t\tif (!dataSource) {\n\t\t\tif (window.wxlogging) {\n\t\t\t\tconsole.log('dataSource is empty!');\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tObject.assign(this.options, options); // equal to {leaflet}.GridLayer.prototype.initialize.call(this, options); // essential for Leaflet' options initializing from parameters\n\n\t\tthis.styles = WxGetColorStyles();\n\t\tif (!dataSource.ext) dataSource.ext = 'webp';\n\n\t\t// tiles will be stored here. There is a protected 'Leaflet's GridLayer._tiles'\n\t\t// but at some point I decided to move to my own Map.\n\t\tthis.wxtiles = new Map();\n\n\t\tconst lazySetup = () => {\n\t\t\t// Lazy loading\n\t\t\tif (window.wxlogging) {\n\t\t\t\tconsole.log('Setup:', dataSource.name);\n\t\t\t}\n\n\t\t\tthis.setupCompletePromise = this._setUpDataSet(dataSource);\n\t\t\t// '.then' since I don't want lazySetup to be 'async'\n\t\t\tthis.setupCompletePromise.then(() => {\n\t\t\t\tif (window.wxlogging) {\n\t\t\t\t\tconsole.log('Setup complete:', this.dataSource.name, (this.error && '. error:' + this.error) || '');\n\t\t\t\t}\n\n\t\t\t\t// should be here! 'this.wxtiles' should only be formed and processed if setup complete\n\t\t\t\tthis._initializeEvents();\n\n\t\t\t\t// By the time when setup complete, layer could be removed from _map, so, dont call _onAddl\n\t\t\t\t// the same happens if lazy === false\n\t\t\t\tif (this._map) {\n\t\t\t\t\tthis._onAddL(); // simulates addTo(map)\n\t\t\t\t}\n\n\t\t\t\tthis.fire('setupcomplete', { layer: this });\n\t\t\t});\n\t\t};\n\n\t\tif (lazy) {\n\t\t\tthis.once('add', lazySetup); // Lazy loading // sets it up only if user wants to visualise it\n\t\t} else {\n\t\t\tlazySetup();\n\t\t}\n\t\tthis.on('remove', this._onRemoveL, this); // moved from '_initializeEvents' due to 'lazy loading'\n\t}, // initialize\n\n\t// Leaflet's calling this, don't use it directly!\n\tcreateTile(coords, done) {\n\t\t// const done = () => {};\n\t\tif (this.error) {\n\t\t\tsetTimeout(done); // if 'done' is not used then visual issue happens sometimes!\n\t\t\treturn Object.assign(createEl('div', 'error-tile'), { innerHTML: this.error });\n\t\t}\n\n\t\treturn TileCreate({ layer: this, coords, done });\n\t}, // createTile\n\n\tgetSetupCompletePromise() {\n\t\treturn this.setupCompletePromise;\n\t},\n\n\t// get all the information about tile and point it represents\n\t// zoom - current zoom level\n\t// latlng - pixel on the map\n\tgetTile(latlng) {\n\t\tif (!this._map || this.error) return;\n\t\tconst zoom = this._map.getZoom();\n\t\tconst { x, y } = this._map.project(latlng, zoom);\n\t\tconst coords = { x: ~~(x / 256), y: ~~(y / 256) };\n\t\tconst wxtile = this.wxtiles.get(`${coords.x}:${coords.y}:${zoom}`);\n\t\tif (!wxtile || !wxtile.data) return; // tile is being created and not ready yet\n\t\tconst tilePoint = { x: ~~(x - coords.x * 256), y: ~~(y - coords.y * 256) };\n\n\t\tconst tileData = wxtile.getData(tilePoint);\n\t\tif (!tileData) return; // oops! no data\n\t\tconst { raw, data } = tileData;\n\t\tconst rgba = this.clut.colorsI[raw];\n\t\tconst hexColor = RGBtoHEX(rgba);\n\t\tconst inStyleUnits = this.clut.DataToStyle(data);\n\t\treturn { tile: wxtile, data, raw, rgba, hexColor, inStyleUnits, tilePoint, units: this.style.units };\n\t}, // getTile\n\n\tsetStyle(name) {\n\t\tif (!this.dataSource) {\n\t\t\tif (window.wxlogging) {\n\t\t\t\tconsole.log('setStyle: failed. Lazy setup not finished yet.');\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.dataSource.styleName === name && name !== 'custom') return; // nothing to setup\n\t\tif (name) this.dataSource.styleName = name; // if name === undefined, use internal name for the first setup\n\t\tif (name === 'custom' && this.styles.custom) {\n\t\t\t// perform inheritance\n\t\t\tif (!this.styles.custom.parent || !(this.styles.custom.parent in this.styles)) {\n\t\t\t\tthis.styles.custom.parent = 'base';\n\t\t\t}\n\t\t\tconst parentStyle = this.styles[this.styles.custom.parent];\n\t\t\tthis.styles.custom = Object.assign(Object.assign({}, parentStyle), this.styles.custom);\n\t\t}\n\n\t\tif (this.dataSource.styleName in this.styles) {\n\t\t\tif (Array.isArray(this.styles[this.dataSource.styleName])) {\n\t\t\t\t// if general styleName is used and it is an Array, then use the styleName[0] of unrolled styles\n\t\t\t\tthis.dataSource.styleName += '[0]';\n\t\t\t}\n\t\t} else {\n\t\t\tthis.dataSource.styleName = this.dataSource.name + '[0]';\n\t\t\tif (!(this.dataSource.styleName in this.styles)) {\n\t\t\t\tthis.dataSource.styleName = 'base';\n\t\t\t\tif (window.wxlogging) console.log(`cant find the style (${name}), default is used`);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tconst ustyle = this.styles[this.dataSource.styleName];\n\t\t\tthis.style = Object.assign({}, ustyle); // deep copy, so could be (and is) changed\n\t\t\t// rectify style.streamLineColor\n\t\t\tconst c = this.style.streamLineColor;\n\t\t\tif (c !== 'none' && c.length < 7) {\n\t\t\t\tthis.style.streamLineColor = '#' + c[1] + c[1] + c[2] + c[2] + c[3] + c[3];\n\t\t\t}\n\n\t\t\tconst minmax = this.dataSource.minmax[0];\n\t\t\tthis.clut = new RawCLUT(this.style, this.dataSource.units, minmax, this.vector);\n\t\t} catch (c) {\n\t\t\tthis.error = 'setStyle: impossible error in RawCLUT';\n\t\t\tif (window.wxlogging) console.log(this.error, c);\n\t\t\treturn;\n\t\t}\n\t\tif (name) {\n\t\t\tthis._checkAndStartSlinesAnimation();\n\t\t\tthis._reloadTiles();\n\t\t}\n\n\t\tif (window.wxlogging) console.log('setStyle: \"' + this.dataSource.styleName + '\" for ' + this.dataSource.name + ' complete.');\n\n\t\tthis.fire('setstyle', { layer: this });\n\t}, // setStyle\n\n\t// string\n\tgetStyle() {\n\t\tif (!this.dataSource) {\n\t\t\tif (window.wxlogging) {\n\t\t\t\tconsole.log('getStyle: failed. Lazy setup not finished yet.');\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\treturn (this.dataSource && this.dataSource.styleName) || '';\n\t},\n\n\t// string\n\tgetStyleName() {\n\t\tif (!this.dataSource) {\n\t\t\tif (window.wxlogging) {\n\t\t\t\tconsole.log('getStyleName: failed. Lazy setup not finished yet.');\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\treturn (this.dataSource && this.style && this.style.name) || 'no style';\n\t},\n\n\t// unixTime - ms since 00:00:00 UTC on 1 January 1970\n\tsetTime(unixTime) {\n\t\tif (!this.dataSource) {\n\t\t\tif (window.wxlogging) {\n\t\t\t\tconsole.log('setTime: failed. Lazy setup not finished yet.');\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t// NOTE: when tiles are still loading data, and a user sets a new time-stamp... a new timestemp could be\n\t\t// loaded before old timestemp (hello network lags) then new data will be substituted with old data\n\t\t// and some visual issues can come. Have no idea how to prevent this.\n\t\tconst layerTime = this._getClosestTimeString(unixTime);\n\t\tif (this.dataSource.time !== layerTime) {\n\t\t\tthis.dataSource.time = layerTime;\n\t\t\t// update BaseURL\n\t\t\tthis.dataSource.baseURL = this.dataSource.originURI + this.dataSource.instance + `{var}/${this.dataSource.time}/{z}/{x}/{y}.${this.dataSource.ext}`; // webp\n\n\t\t\tthis.fire('settime', { layer: this, layerTime });\n\n\t\t\tif (window.wxlogging) console.log('setTime: ' + layerTime + ' for ' + this.dataSource.name + ' complete.');\n\n\t\t\tconst reloadPromice = this._reloadTiles();\n\n\t\t\t/* Ugly workaround for datasets like NZ_Radar where each timestep can have minmax */\n\t\t\t/* I check if minmax changed, then get\\set a new minmax and re-setup the style */\n\t\t\treloadPromice.then(() => {\n\t\t\t\tconst wxtile = this.wxtiles.values().next().value;\n\t\t\t\tif (!wxtile?.data.length) return;\n\t\t\t\tconst [cmin, cmax] = this.dataSource.minmax[0];\n\t\t\t\tconst { dmin, dmax } = wxtile.data[0];\n\t\t\t\tif (Math.abs(dmin - cmin) > 0.01 || Math.abs(dmax - cmax) > 0.01) {\n\t\t\t\t\tthis.dataSource.minmax = wxtile.data.map((d) => [d.dmin, d.dmax]);\n\t\t\t\t\tthis._updateMinMax();\n\t\t\t\t\tthis.setStyle();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn reloadPromice;\n\t\t}\n\t\treturn Promise.resolve();\n\t}, // setTime\n\n\t// string\n\tgetTime() {\n\t\tif (!this.dataSource) {\n\t\t\tif (window.wxlogging) {\n\t\t\t\tconsole.log('getTime: failed. Lazy setup not finished yet.');\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\treturn this.dataSource.time;\n\t},\n\n\t// Arra of strings (times)\n\tgetTimes() {\n\t\tif (!this.dataSource) {\n\t\t\tif (window.wxlogging) {\n\t\t\t\tconsole.log('getTimes: failed. Lazy setup not finished yet.');\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\treturn this.dataSource.meta.times;\n\t},\n\n\t// check if data has been changed since last init\n\tasync checkDataChanged() {\n\t\tif (!this.dataSource) {\n\t\t\tif (window.wxlogging) console.log('getTimes: failed. Lazy setup not finished yet.');\n\t\t\treturn Promise.resolve(false);\n\t\t}\n\t\tconst instances = await fetchJson(this.dataSource.originURI + 'instances.json');\n\t\tconst instance = instances[instances.length - 1] + '/';\n\t\tif (this.dataSource.instance !== instance) return true;\n\t\t// instance didn't change. Check meta.times\n\t\tconst meta = await fetchJson(this.dataSource.originURI + instance + 'meta.json');\n\t\treturn this.dataSource.meta.times.toString() !== meta.times.toString();\n\t},\n\n\t// usefull if data is changed on server (checkable with 'checkDataChanged')\n\treloadData() {\n\t\treturn this._setUpDataSet(); // forces to reload data within the same dataset, so no parameters needed\n\t},\n\n\t// getLegendData - data to render a proper legend\n\t// pixSize - width of a canvas to render this legend\n\t// output:\n\t// legend - object\n\t//   legend.units - (string) units\n\t//   legend.colors - Uint32Array(pixSize) - legend colors RGBA.\n\t//   legend.ticks - ([tick])aray of ticks\n\t//     tick.data - (float) data in legend units\n\t//     tick.color - (string) representation of a color at this tick\n\t//     tick.pos - (int) position in pixels of this tick on the legend. If style uses values out of data's range it clamps pos to (0, pixSize)\n\tgetLegendData(legendSize) {\n\t\tif (this.error) return;\n\t\tif (!this.clut) {\n\t\t\tif (window.wxlogging) {\n\t\t\t\tconsole.log('getLegendData: failed. Lazy setup not finished yet:' + this.dataSource.name);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\treturn createLegend(legendSize, this.style);\n\t},\n\n\tsetTimeAnimationMode(l = 2) {\n\t\t// TODO: no need to make it coarse on deep zooms\n\t\tthis.oldMaxZoom = this.dataSource.meta.maxZoom;\n\t\tconst mz = this._map.getZoom();\n\t\tconst minMaxZoom = mz < this.oldMaxZoom ? mz : this.oldMaxZoom;\n\t\tconst newMaxZoom = minMaxZoom - l;\n\t\tthis.dataSource.meta.maxZoom = newMaxZoom < 0 ? 0 : newMaxZoom;\n\t},\n\n\tunsetTimeAnimationMode() {\n\t\tif (!this.oldMaxZoom || !this.dataSource?.meta?.maxZoom) return;\n\t\tthis.dataSource.meta.maxZoom = this.oldMaxZoom;\n\t\tthis._reloadTiles();\n\t},\n\n\tgetMinMax() {\n\t\tconst [min, max] = this.dataSource.minmax[0];\n\t\treturn { min, max };\n\t},\n\n\tasync _setUpDataSet(dataSource) {\n\t\tif (\n\t\t\tdataSource &&\n\t\t\t!(dataSource.dataset && dataSource.variables && Array.isArray(dataSource.variables) && dataSource.variables.length > 0 && dataSource.variables.length < 3)\n\t\t) {\n\t\t\tthis.error = dataSource.name + ': dataSource error';\n\t\t\tif (window.wxlogging) console.log(this.error);\n\t\t\treturn;\n\t\t}\n\n\t\t// if no parameters passed, then a new instance is being loaded.\n\t\t// Otherwise it's the first setup\n\t\tif (dataSource) this.dataSource = dataSource;\n\n\t\tthis._stopLoadingResetLoadDataFunc(); // As Layer could be setup multiple times, use _stopLoadingResetLoadDataFunc\n\n\t\tthis.dataSource.originURI = this.dataSource.serverURI + '/' + this.dataSource.dataset + '/';\n\n\t\ttry {\n\t\t\tconst instances = await fetchJson(this.dataSource.originURI + 'instances.json');\n\t\t\tthis.dataSource.instance = instances[instances.length - 1] + '/';\n\t\t\t// this.dataSource.instance = (await fetchJson(this.dataSource.originURI + 'instance.json')) + '/';\n\t\t} catch {\n\t\t\tthis.error = this.dataSource.name + ': load instances.json error';\n\t\t\tif (window.wxlogging) console.log(this.error);\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tconst URI = this.dataSource.originURI + this.dataSource.instance + 'meta.json';\n\t\t\tthis.dataSource.meta = await fetchJson(URI);\n\t\t} catch {\n\t\t\tthis.error = this.dataSource.name + ': load meta.json error';\n\t\t\tif (window.wxlogging) console.log(this.error);\n\t\t\treturn;\n\t\t}\n\n\t\tthis.vector = this.dataSource.variables.length === 2;\n\t\tthis.animation = this.vector;\n\n\t\tthis.dataSource.units = this.dataSource.meta.variablesMeta[this.dataSource.variables[0]].units;\n\t\tthis.dataSource.minmax = this.dataSource.variables.map((v) => [this.dataSource.meta.variablesMeta[v].min, this.dataSource.meta.variablesMeta[v].max]);\n\t\tthis._updateMinMax();\n\n\t\tif (dataSource) {\n\t\t\tthis.setTime(Date.now());\n\t\t\tthis.setStyle();\n\t\t}\n\t}, // _setUpDataSet\n\n\t_updateMinMax() {\n\t\tif (!this.vector) return;\n\t\tconst [[udmin, udmax], [vdmin, vdmax]] = this.dataSource.minmax;\n\t\tthis.dataSource.minmax.unshift([0, 1.42 * Math.max(-udmin, udmax, -vdmin, vdmax)]);\n\t},\n\n\t_initializeEvents() {\n\t\t// class constructor 2 stage\n\t\tif (this.error) {\n\t\t\treturn;\n\t\t}\n\n\t\t// to maintain tiles' Map\n\t\tthis.on('tileload', (t) => {\n\t\t\tthis.wxtiles.set(`${t.coords.x}:${t.coords.y}:${t.coords.z}`, t.tile.wxtile);\n\t\t});\n\t\tthis.on('tileunload', (t) => {\n\t\t\tthis.wxtiles.delete(`${t.coords.x}:${t.coords.y}:${t.coords.z}`);\n\t\t});\n\n\t\tthis.on('add', this._onAddL, this);\n\t\t// this.on('remove'...) // moved to 'initialize' to avoid appearance of zombie layers due to 'lazy loading' if a user clicks on layers too fast\n\t},\n\n\t_checkZoom() {\n\t\t// used in _onAddL() & _onRemoveL()\n\t\t// id zoom > maxZoom then the same tiles are used, so could be loaded from cache.\n\t\t// Otherwise cache should be reset\n\t\tif (!this._map || this._map.getZoom() < this.dataSource.meta.maxZoom) {\n\t\t\tthis._stopLoadingResetLoadDataFunc();\n\t\t}\n\t},\n\n\t// onAdd is used in the leaflet library! so I renamed it.\n\t_onAddL() {\n\t\tif (window.wxlogging) {\n\t\t\tconsole.log('onadd:', this.dataSource.name);\n\t\t}\n\n\t\tif (!this.error) this._map.on('zoomstart', this._checkZoom, this); // fired when tiles are about to start loading... when zoom or shift\n\n\t\tthis.setupCompletePromise.then(() => {\n\t\t\tthis.redraw(); // need to force all tiles to be reloaded due to lazy setup\n\t\t\tthis._checkAndStartSlinesAnimation();\n\t\t});\n\t},\n\n\t_onRemoveL() {\n\t\tif (window.wxlogging) {\n\t\t\tconsole.log('onremove:', this.dataSource.name);\n\t\t}\n\n\t\tthis._map.off('zoomstart', this._checkZoom, this);\n\n\t\tthis.setupCompletePromise.then(() => {\n\t\t\t// this promise is used to avoid appearance of zombie layers due to 'lazy loading' if a user adds->removes layers too fast\n\t\t\tthis._stopLoadingResetLoadDataFunc(); // remove cache\n\t\t\tthis._stopSlinesAnimation();\n\t\t});\n\t},\n\n\t_stopLoadingResetLoadDataFunc() {\n\t\tthis.loadData?.abort();\n\t\tthis.loadData = loadDataPictureCachedAbortable(); // and reset cache\n\t},\n\n\t_checkAndStartSlinesAnimation() {\n\t\tif (this.animFrame || !this.animation || !this.vector || !this.style.streamLineColor || this.style.streamLineColor === 'none') return;\n\n\t\tconst drawSLines = (timeStemp) => {\n\t\t\tif (!this.animation || this.style.streamLineStatic) {\n\t\t\t\t// if during animation a user stops it\n\t\t\t\tthis._stopSlinesAnimation();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.wxtiles.forEach((wxtile) => wxtile.drawSLines(timeStemp));\n\t\t\tthis.animFrame = requestAnimationFrame(drawSLines);\n\t\t};\n\t\tdrawSLines();\n\t},\n\n\t_stopSlinesAnimation() {\n\t\tcancelAnimationFrame(this.animFrame);\n\t\tthis.wxtiles.forEach((wxtile) => wxtile.clearSLinesCanvas());\n\t\tthis.animFrame = 0;\n\t},\n\n\t_getClosestTimeString(unixTime) {\n\t\t// Take the next this.dataSource.meta.times[]'s after unixTime OR the last\n\n\t\treturn (\n\t\t\tthis.dataSource.meta.times.find((stime) => new Date(stime).getTime() >= unixTime) || this.dataSource.meta.times[this.dataSource.meta.times.length - 1]\n\t\t);\n\n\t\t// for (const stime of this.dataSource.meta.times) {\n\t\t// \tconst t = new Date(stime).getTime(); // this.dataSource.meta.times are strings\n\t\t// \tif (t >= unixTime) {\n\t\t// \t\treturn stime;\n\t\t// \t}\n\t\t// }\n\t\t// return this.dataSource.meta.times[this.dataSource.meta.times.length - 1]; // last\n\t}, // _getClosestTimeString\n\n\t_redrawTiles() {\n\t\tif (!this.wxtiles || this.animationRedrawID) return; // in case animation was queued\n\t\tthis.animationRedrawID = requestAnimationFrame(() => {\n\t\t\tthis.wxtiles.forEach((wxtile) => wxtile.draw());\n\t\t\tthis.animationRedrawID = null;\n\t\t});\n\t}, // _redrawTiles\n\n\t_reloadTiles() {\n\t\tconst promises = [];\n\t\tthis.wxtiles.forEach((wxtile) => promises.push(wxtile._load()));\n\t\tconst reloadedPromice = Promise.all(promises);\n\t\treloadedPromice.then(() => this._redrawTiles());\n\t\treturn reloadedPromice; // we shouldn't 'await' here! Give another promise instead\n\t}, // _reloadTiles\n}; // WxGridLayerProto\n"],
  "mappings": "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",
  "names": []
}
